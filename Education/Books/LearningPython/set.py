# МНОЖЕСТВА

X = set ('spam') # Создать множество из последовательности
Y = {'h','a','m'} # Создать множество с помощью литералов
a = X, Y # Кортеж из двух множеств без круглых скобок
b = X & Y # Пересечение
c = X | Y # Объединение
d = X - Y # Разность
e = X > Y # Надмножество
f = {n ** 2 for n in [1, 2, 3, 4]} # Включения множеств
g = list(set([1, 2, 1, 3, 1])) # Фильтрация дубликатов
h = set ('spam') - set ('ham') # Нахождение разностей в коллекциях
j = set ('spam') == set('asmp') # Нейтральная к порядку проверка
k = 'p' in set('spam'), 'p' in 'spam', 'ham' in ['eggs', 'spam', 'ham'] 

# проверка членства во множест­ве in — такое выражение определено для работы со всеми остальными типами коллек­ций, 
# где оно также выполняет проверку членства (или поиск, если вы предпочитаете процедурные термины).
qw = set('abode')
sd = set('bdxyz')
vb = 'o' in qw # проверка членства 'o' во множест­ве qw
zx = 'e' in 'Camelot'
xc = 12 in [1, 3, 5, 15]

# ме­тод "add" вставляет один элемент, "update" представляет собой объединение на месте, а "remove" удаляет элемент по значению 
# (вызовите dir для любого экземпляра множес­тва либо для имени типа set, чтобы увидеть все доступные методы).
po = qw.intersection (sd) # To же, что и x & у. Пересечение множеств
qw.add('spam') # Вставка элемента "spam"
po.update(set(['w', 's'])) # Слияние: объединение на месте
qw.remove('b') # Удаление одного элемента

# Как итерируемые контейнеры, множества могут также использоваться в операциях вроде "lеп", циклах "for" и списковых включениях. 
# Тем не менее, из-за того, что мно­жества неупорядочены, они не поддерживают операции над последовательностями, 
# подобные индексации и нарезанию
for item in set('abc'): 
    print (item * 3)

# выражения с множествами в общем случае тре­буют двух множеств, их аналоги, основанные на методах, часто способны работать 
# также и с любым, итерируемым типом:
S = set([1, 2, 3])
gh = S | set([3, 4]) # Выражения требуют двух множеств. Это объединение.
hj = S.union([3, 4]) # то же самое
jk = S.intersection((11, 34, 53)) # Пересечение множества и (11, 34, 53)
lk = S.issubset (range (-5, 5))

# Литералы множеств
a = set([1, 2, 3, 4])
b = set('spam')

a1 = {1, 2, 3, 4} # написано по-другому чем "a"
b1 = {'s', 'p', 'a', 'm'}
b1.add('alot') # добавили в "b1" элемент "alot"

# Все операции обработки множеств работают аналогично, но результирующие множества выводятся по-другому:
S1 = {1, 2, 3, 4}
a = S1 & {1, 3} # Пересечение
b = {1, 5, 3 , 6} | S1 # объединение
c = S1 - {1, 3, 4} # разность 
d = S1 > {1, 3} # надмножество

S = set() # Инициализация пустого множества

# множества способны содержать только объекты неизменяе­мых (также известных как “хешируемые”) типов. 
# Следовательно, списки и словари не могут встраиваться во множества, но кортежи могут, если необходимо хранить 
# состав­ные значения. В случае применения в операциях над множествами кортежи сравнива­ются по их полным значениям:

# S.add([1, 2, 3]) # выдает ошибку. Список не встраивается в множество 
# S.add({a:1}) # выдает ошибку. Словарь не встраивается в множество 
S.add((1, 2, 3)) # кортеж работает
a = (1, 2, 3) in S # Членство кортежа в "S"

# Сами множества изменяемы и соответственно не могут вкладываться в другие множес­тва напрямую. 
# Если нужно хранить множество внутри другого множества, то встроен­ная функция "frozenset" работает в точности как set, 
# но создает неизменяемое мно­жество, которое не допускает модификацию и потому может быть внедрено в другие множества

# Включения множеств
# Включения множеств запускают цикл и на каждой итерации накапливают результат выражения; переменная цикла предоставляет 
# до­ступ к значению текущей итерации для использования в накапливающем выражении. Результатом будет новое множество, 
# созданное за счет выполнения кода, с обычным поведением множества.
a =  {х ** 2 for х in [1, 2, 3, 4]} # В этом выражении цикл записывается справа, а накапливающее выражение — сле­ва (х ** 2).
b = {х for х in 'spam'}
c = {с * 4 for с in 'spam'} # Множество накопленных результатов выражения

# Для чего используются множества?
# множества допускается использовать для фильтрации дубликатов из коллекций, хотя элементы в ходе процесса могут 
# оказаться переупорядоченными, т.к. в общем случае множества являются неупорядоченными. 
# Коллекцию нужно лишь преобразовать во множество и затем выполнить обратное преобразование.
L = [1, 2, 1, 3, 2, 4, 5]
L = list(set(L)) # Удаление дубликатов
N = list (set ([ 'уу' , 'сс', 'аа', 'хх', 'dd', 'аа'])) # Но порядок может измениться
M = set([1, 3, 5, 7]) - set([1, 2, 4, 5, 6]) # Найти различия в списках
O = set ('abcdefg') - set ('abdghij') # Найти различия в строках
Z = set ('spam') -set(['h', 'a', 'm']) # Найти различия, разнородные типы

# Множества также можно использовать для выполнения проверок на равенство, ней­тральное к порядку, 
# за счет предварительного преобразования во множество, потому что порядок в нем не имеет значения.
LI, L2 = [1, 3, 5, 2, 4] , [2, 5, 3, 4, 1]
a = LI == L2 # В последовательностях порядок имеет значение
b = set(LI) == set(L2) # Проверка на равенство, нейтральное к порядку
c = 'spam' == 'asmp'
d = set('spam') == set('asmp')

# Множества также можно использовать для отслеживания того, где вы уже были, при обходе графа или другой циклической структуры.

print(d)