Типы переменных.
    Переменная никогда не располагает какой-либо информацией о типе или о свя­занных с ним ограничениях. 
Понятие типа обитает в объектах, не в именах. Переменные являются обобщенными по своей природе; 
они всегда просто ссы­лаются на определенный объект в конкретный момент времени. 
    Когда переменная встречается в выражении, она тотчас же заменяется объек­том, на который в текущий момент ссылается, 
каким бы он ни был.
    В итоге переменные создаются, когда присваиваются, могут ссылаться на объекты любых типов 
и должны быть присвоены перед ссылкой на них.
    
    Скажем, когда переменной присваива­ется значение:
    а = 3 # Присвоить имени объект
    Следующие шаги отражают работу всех присваиваний в языке Python.
    1. Создание объекта для представления значения 3.
    2. Создание переменной а, если она еще не существует.
    3. Связывание переменной а с новым объектом 3.

    Переменные всегда ссылаются на объекты и никогда на другие переменные, но более крупные объекты могут быть связаны 
с другими объектами (например, объект списка имеет ссылки на содержащиеся в нем объекты). Такие связи от переменных к объектам 
в Python называются ссылками', т.е. ссылка — это своего рода ассоциация, реализованная как указатель в памяти. Всякий раз, когда
переменная используется в более позднее время (т.е. на нее производится ссылка),
Python автоматически следует по связи от переменной к объекту. 
    Переменные — это записи в системной таблице, в которых предусмотрены мес­та для связей с объектами.
    Объекты — это области выделенной памяти с достаточным пространством для представления значений, для которых они предназначены.
    Ссылки — это следуемые указатели от переменных к объектам.
    
    на понятийном уровне каждый раз, когда вы в своем сценарии ге­нерируете новое значение путем выполнения выражения, 
Python создает новый объект (т.е. участок памяти) для представления этого значения.
    Каждый объект также содер­жит два стандартных заголовочных поля: обозначение типа, применяемое для пометки
типа объекта, и счетчик ссылок, используемый для определения, когда можно освобо­дить память, которую занимает объект.

Типы обитают в объектах, не в переменных.

В Python при присваивании имени нового объекта область памяти, занимаемая предыдущим объектом, освобождается в случае, 
если на него не ссылается любое другое имя или объект. Такое автоматическое освобождение памяти объектов
известно как сборка мусора.
х = 42
х = 'shrubbery' # Освободить память, занимаемую 42
х = 3.1415 # Освободить память, занимаемую 'shrubbery'
х = [1, 2, 3] # Освободить память, занимаемую 3.1415

Разделяемые ссылки
а = 3
Ь = а
    Вторая команда приводит к тому, что Python создает переменную Ь; перемен­ная а здесь используется и не присваивается, 
поэтому она заменяется объектом, на который ссылается (3), а в Ь обеспечивается ссылка на данный объект. 
Совокупный эффект в том, что переменные а и Ь в итоге ссылаются на тот же самый объект 
(т.е. указывают на один и тот же участок памяти). Такой сценарий в Python с множеством имен, ссылающихся на тот же самый объект,
обычно называется разделяемой ссылкой, (а иногда просто разделяемым объектом).
    Обратите внимание, что когда это происходит, имена а иЬ не связаны друг с другом напрямую; на самом деле 
в Python вообще нет способа связать одну переменную с другой. Наоборот, 
обе переменные указывают на один и тот же объект через свои ссылки.

Разделяемые ссылки и изменения на месте
    Cписки, которые поддерживают присваивания по позиции на месте, представляют собой просто коллекции других объектов, 
    запи­санные в квадратных скобках:
    L1 = [2, 3, 4]
    L2 = L1
    L1 = 24
    Такое присваивание просто устанавливает L1 в другой объект; L2 по-прежнему ссы­лается на первоначальный список.
    На самом деле мы здесь не модифицировали сам список L1, а изменили компонент объекта, на который L1 ссылается. 
Изменение такого рода перезаписывает часть значе­ния спискового объекта на месте.

    L1 = [2, 3, 4]
    L2 - L1 [:] # Создать копию L1 (или list(Ll), сору. copy (L1) и т.д.)
    L[0] = 24
    Здесь изменение, внесенное через L1, не влияет на L2, поскольку L2 ссылается на копию, а не на оригинал объекта, 
на который ссылается L1; т.е. две переменные ука­зывают на разные участки памяти.
    
    Подход с нарезанием не будет работать с другими изменяемыми основными типами, словарями и множествами, 
потому что они не явля­ются последовательностями. Для копирования словарей или множеств взамен нужно использовать вызов 
их метода Х.сору () или передавать исходный объект их именам типов, diet и set.

    L = [1, 2, 3]
    М = L # М и L ссылаются на один и тот же объект
    L == М # Одинаковые значения
    L is М # Одинаковые объекты
    Oперация "==" предусматривает проверку, имеют ли два ссылаемых объекта одинаковые значения; 
такой метод почти всегда используется для проверок на предмет равенства в Python.
    Oперация is, проверяет идентичность — она возвращает True, только если оба имени указывают на точно тот же самый 
объ­ект, поэтому операция is является гораздо более строгой формой проверки равенс­тва и редко применяется в большинстве программ.

    L = [1, 2, 3]
    М = [1, 2, 3] # М и L ссылаются на разные объекты
    L == М # Одинаковые значения
    L is М # Разные объекты

    х = 42
    Y = 42 # Должны быть двумя разными объектами
    X == Y
    X is Y # Как бы то ни было, тот же самый объект: кеширование в действии!    
    В последнем взаимодействии X и Y должны давать True в операции == (то же са­мое значение), но не в операции is 
(тот же самый объект), потому что мы выполняли два разных литеральных выражения (42). Однако поскольку небольшие целые числа
и строки кешируются и используются повторно, операция is сообщает о том, что они ссылаются на тот же самый одиночный объект.
Данный объект кешируется и его повторное применение не имеет отношения к ва­шему коду (если только вы не выполняете проверку is!).

    Bсегда можете поинтересо­ваться у Python, сколько ссылок на объект имеется: функция getrefcount из стандар­тного 
модуля sys возвращает счетчик ссылок объекта.
    import sys
    sys.getrefcount(1) 

"Слабые" ссылки
    Cлабая ссылка, реализуемая стандартным библиотечным модулем weakref, представляет собой ссылку на объект, 
которая сама по себе не препятствует выпол­нению сборки мусора в отношении этого объекта. Если последними оставшимися
ссылками на объект оказываются слабые ссылки, тогда выделенная под объект па­мять освобождается, 
а слабые ссылки автоматически удаляются (или уведомляются об освобождении как-то иначе).


