# Строки в одинарных и двойных кавычках являются одинаковыми

# print('knighf"s')
# print("knighf's")
# print('spam' 'qwerty') # без запятой выполняет автомати­ческую конкатенацию соседних строк
# title = "Meaning " 'of' " Life"; print(title)    # Неявная конкатенация

# s = 'a\nb\tc'; print(s); print(len(s))

# mantra = '''Always look 
# ... on the bright ... 
# side of life.'''; print(mantra)

# myjob = 'hacker'
# for с in myjob: print(с, end=' ') # Проход по элементам с выводом
# print("z" in myjob) # He найден

# a = 'spam' in 'abcspamdef'; print(a) # Поиск подстроки без возвращения позиции

# # Индексация и нарезание
# s = 'spam'
# a = s[0]; b =s[-2]; print(a, b)  # Индексация с начала или с конца

# q = s[1:3]; w = s[1:]; e = s[1]; print(q, w, e) # Нарезание: извлечение сегмента

# # Индексация (S[i]) извлекает компоненты по смещениям:
# s = 'spam'
# print(s[0]) # извлекает первый элемент;
# print(s[-2]) # извлекает второй элемент с конца (подобно S[len(S) - 2])

# Нарезание (S[i:j]) извлекает непрерывные сегменты последовательности:
# s = 'qwerty'
# print(s, s[1:3]) #извлекает элементы, которые начинаются со смещения 1 и заканчивают­ся по смещению 3, не включая его;
# print(s, s[1:]) # извлекает элементы, начиная со смещения 1 и до конца (длина последо­вательности);
# print(s, s[:3]) # извлекает элементы, которые начинаются со смещения которые начина­ются со смещения 0 
#              # и заканчиваются по смещению 3, не включая его;
# print(s, s[:-1]) # извлекает элементы, начиная со смещения 0 и заканчивая последним элементом, но не включая его;             
# print(s, s[:]) # извлекает элементы, начиная со смещения 0 и до конца — создает копию верхнего уровня 's'            
             
# # Расширенное нарезание (s[i:j:k]) принимает шаг (или страйд (большой шаг)) к, который по умолчанию равен +1            
# S = 'abcdefghijklmnop'
# print(S[1:10:2]) # Пропуск элементов
# print(S[::2])
# print(S[::-1]) # разворачивает строку
# print(S [5:1:-1])  # извлекает элементы со второго по пятый в обратном порядке        
 
# print (str('spam'), repr('spam'))

# Преобразования кодов символов
# print(ord('s')); print(chr(115))

# s = '5'
# print(chr(ord(s) + 1))

# print('That is %d %s bird!' % (1, 'dead')) # Выражение форматирования:
# print('That is {0} {1} bird! ' .format(1,'dead')) # Метод форматирования
# Тем не менее, вопреки метафоре подстановки результатом форматирования будет новый строковый объект, 
# а не модифицированный старый.
 
# s = 'spam'; result = s.find('pa'); print(result) # Вызов метода find для поиска 'ра ' в строке S 
 
# S = 'spammy'
# a = S[:3] + 'хх' + S[5:] # Нарезать сегменты из S   
# # Но если нужно только заменить подстроку, тогда можно использовать метод 'replace':
# b = S. replace ('mm', 'хх') # Заменить все mm на хх в S
# print(a, b) 
# # Метод 'replace' является более универсальным. Он принимает в качестве аргументов исходную подстроку (любой длины) 
# # и стро­ку (любой длины), которой должна быть заменена исходная подстрока, и выполняет глобальный поиск и замену

# S = 'xxxxSPAMxxxxSPAMxxxx'; 
# where = S.find('SPAM') # Поиск позиции. Нашлась по смещению 4
# a = S[:where] + 'EGGS' + S[(where + 4) :]
# # Метод 'find' возвращает смещение, по которому обнаруживается подстрока (по-умолчанию выполняя поиск с начала), 
# # или -1, если подстрока не найдена.
# b = S.replace('SPAM' , 'EGGS') # Заменить все
# print(a, b)
# # Обратите внимание, что 'replace' каждый раз возвращает новый строковый объ­ект. Поскольку строки неизменяемы, 
# # метод никогда по-настоящему не модифицирует исходную строку на месте, хотя и называется 'replace'!

# line = 'The knights who say Ni?\n'
# # a = line.rstrip() # удаляет \n
# # b = line.upper()  # в верхнем регистре
# с = line.endswith('Ni?\n') # Возвращает флаг, указывающий на то, заканчивается ли строка указанным постфиксом
# d = line.isalpha() # Возвращает флаг, указывающий на то, содержит ли строка только буквы.
# e = line.startswith('The') # Возвращает флаг, указывающий на то, начинается ли строка с указанного префикса.

# x = 1234
# res = 'integers: . . .%d. . .%-6d. . .%06d' % (x, x, x)
# print(res)

# x = 1.23456789
# print('%e | %f | %g' % (x, x, x))
# print('%-6.2f | %05.2f | %+06.1f' % (x, x, x))

# # Выражения форматирования, основанные на словаре
# print('%(qty) d more %(food) s' % {'qty': 1, 'food': 'spam'})

# reply = '''Greetings...
# Hello %(name)s!
# Your age is %(age) s'''
# values = {'name': 'Bob' , 'age': 40}
# print(reply % values)

# food = 'spam'
# qty = 10
# print('%(qty)d more %(food) s' % vars ())

# template = '{0}, {1} and {2}' # По позициям
# print(template.format('spam', 'ham', 'eggs'))

# print('{0:10} = {1:10}' .format('spam' , 123.4567)) # означает первый позиционный аргумент в поле шириной 10 символов
# print('{0:>10} = {1:<10}'.format('spam', 123.4567)) # второй позиционный аргумент, выровненный влево в поле шириной 10 символов
# import sys
# print('{0.platform:>10} - {1[kind]:<10}'.format(sys, dict(kind = 'laptop')))    # атрибут platform первого аргумента, выровнен­ный 
                                                                                # вправо в поле шириной 10 символов
                                                                                
a = 'a\nb\x1f\000d'
print(a.find('7'))                                                                             



       